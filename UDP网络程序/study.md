1. TCP协议叫做传输控制协议（Transmission Control Protocol），TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。

    TCP协议是面向连接的，如果两台主机之间想要进行数据传输，那么必须要先建立连接，当连接建立成功后才能进行数据传输。其次，TCP协议是保证可靠的协议，数据在传输过程中如果出现了丢包、乱序等情况，TCP协议都有对应的解决方法。

2. UDP协议叫做用户数据报协议（User Datagram Protocol），UDP协议是一种无需建立连接的、不可靠的、面向数据报的传输层通信协议。

    使用UDP协议进行通信时无需建立连接，如果两台主机之间想要进行数据传输，那么直接将数据发送给对端主机就行了，但这也就意味着UDP协议是不可靠的，数据在传输过程中如果出现了丢包、乱序等情况，UDP协议本身是不知道的。

socket常见API

1. 创建套接字：（TCP/UDP，客户端+服务器）
```C
    int socket(int domain, int type, int protocol);
```
* `domain`：创建套接字的域或者叫做协议家族，也就是创建套接字的类型。该参数就相当于struct sockaddr结构的前16个位。如果是本地通信就设置为`AF_UNIX`，如果是网络通信就设置为`AF_INET`（IPv4）或AF_INET6（IPv6）。

* `type`：创建套接字时所需的服务类型。其中最常见的服务类型是`SOCK_STREAM`和`SOCK_DGRAM`，如果是基于UDP的网络通信，我们采用的就是`SOCK_DGRAM`，叫做用户数据报服务，如果是基于TCP的网络通信，我们采用的就是`SOCK_STREAM`，叫做流式套接字，提供的是流式服务。

* `protocol`：创建套接字的协议类别。你可以指明为`TCP或UDP`，但该字段一般直接设置为`0`就可以了，设置为0表示的就是默认，此时会根据传入的前两个参数自动推导出你最终需要使用的是哪种协议。

* 套接字创建成功返回一个文件描述符，创建失败返回-1，同时错误码会被设置。





2. 绑定端口号：（TCP/UDP，服务器）
```C
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
* sockfd：绑定的文件的文件描述符。也就是我们创建套接字时获取到的文件描述符。
* addr：网络相关的属性信息，包括协议家族、IP地址、端口号等。
* addrlen：传入的addr结构体的长度。


3. 监听套接字：（TCP，服务器）
```C
    int listen(int sockfd, int backlog);
```
4. 接收请求：（TCP，服务器）
```C
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
5. 建立连接：（TCP，客户端）
```C
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

-套接字不仅支持跨网络的进程间通信，还支持本地的进程间通信（域间套接字）。在进行跨网络通信时我们需要传递的端口号和IP地址，而本地通信则不需要，因此套接字提供了sockaddr_in结构体和sockaddr_un结构体，其中sockaddr_in结构体是用于跨网络通信的，而sockaddr_un结构体是用于本地通信的。

-为了让套接字的网络通信和本地通信能够使用同一套函数接口，于是就出现了sockeaddr结构体，该结构体与sockaddr_in和sockaddr_un的结构都不相同，但这三个结构体头部的16个比特位都是一样的，这个字段叫做协议家族。


对于一般的普通文件来说，当用户通过文件描述符将数据写到文件缓冲区，然后再把数据刷到磁盘上就完成了数据的写入操作。而对于现在socket函数打开的“网络文件”来说，当用户将数据写到文件缓冲区后，操作系统会定期将数据刷到网卡里面，而网卡则是负责数据发送的，因此数据最终就发送到了网络当中。

### 服务端绑定

现在套接字已经创建成功了，但作为一款服务器来讲，如果只是把套接字创建好了，那我们也只是在系统层面上打开了一个文件，操作系统将来并不知道是要将数据写入到磁盘还是刷到网卡，此时该文件还没有与网络关联起来。