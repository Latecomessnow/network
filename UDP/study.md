1. TCP协议叫做传输控制协议（Transmission Control Protocol），TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。

    TCP协议是面向连接的，如果两台主机之间想要进行数据传输，那么必须要先建立连接，当连接建立成功后才能进行数据传输。其次，TCP协议是保证可靠的协议，数据在传输过程中如果出现了丢包、乱序等情况，TCP协议都有对应的解决方法。

2. UDP协议叫做用户数据报协议（User Datagram Protocol），UDP协议是一种无需建立连接的、不可靠的、面向数据报的传输层通信协议。

    使用UDP协议进行通信时无需建立连接，如果两台主机之间想要进行数据传输，那么直接将数据发送给对端主机就行了，但这也就意味着UDP协议是不可靠的，数据在传输过程中如果出现了丢包、乱序等情况，UDP协议本身是不知道的。

socket常见API

1. 创建套接字：（TCP/UDP，客户端+服务器）
```C
    int socket(int domain, int type, int protocol);
```
* `domain`：创建套接字的域或者叫做协议家族，也就是创建套接字的类型。该参数就相当于struct sockaddr结构的前16个位。如果是本地通信就设置为`AF_UNIX`，如果是网络通信就设置为`AF_INET`（IPv4）或AF_INET6（IPv6）。

* `type`：创建套接字时所需的服务类型。其中最常见的服务类型是`SOCK_STREAM`和`SOCK_DGRAM`，如果是基于UDP的网络通信，我们采用的就是`SOCK_DGRAM`，叫做用户数据报服务，如果是基于TCP的网络通信，我们采用的就是`SOCK_STREAM`，叫做流式套接字，提供的是流式服务。

* `protocol`：创建套接字的协议类别。你可以指明为`TCP或UDP`，但该字段一般直接设置为`0`就可以了，设置为0表示的就是默认，此时会根据传入的前两个参数自动推导出你最终需要使用的是哪种协议。

* 套接字创建成功返回一个文件描述符，创建失败返回-1，同时错误码会被设置。





2. 绑定端口号：（TCP/UDP，服务器）
```C
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
* sockfd：绑定的文件的文件描述符。也就是我们创建套接字时获取到的文件描述符。
* addr：网络相关的属性信息，包括协议家族、IP地址、端口号等。
* addrlen：传入的addr结构体的长度。


3. 监听套接字：（TCP，服务器）
```C
    int listen(int sockfd, int backlog);
```
4. 接收请求：（TCP，服务器）
```C
    int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
5. 建立连接：（TCP，客户端）
```C
    int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```

-套接字不仅支持跨网络的进程间通信，还支持本地的进程间通信（域间套接字）。在进行跨网络通信时我们需要传递的端口号和IP地址，而本地通信则不需要，因此套接字提供了sockaddr_in结构体和sockaddr_un结构体，其中sockaddr_in结构体是用于跨网络通信的，而sockaddr_un结构体是用于本地通信的。

-为了让套接字的网络通信和本地通信能够使用同一套函数接口，于是就出现了sockeaddr结构体，该结构体与sockaddr_in和sockaddr_un的结构都不相同，但这三个结构体头部的16个比特位都是一样的，这个字段叫做协议家族。


对于一般的普通文件来说，当用户通过文件描述符将数据写到文件缓冲区，然后再把数据刷到磁盘上就完成了数据的写入操作。而对于现在socket函数打开的“网络文件”来说，当用户将数据写到文件缓冲区后，操作系统会定期将数据刷到网卡里面，而网卡则是负责数据发送的，因此数据最终就发送到了网络当中。

### 服务端绑定

现在套接字已经创建成功了，但作为一款服务器来讲，如果只是把套接字创建好了，那我们也只是在系统层面上打开了一个文件，操作系统将来并不知道是要将数据写入到磁盘还是刷到网卡，此时该文件还没有与网络关联起来。

UDP服务器的初始化就只需要创建套接字和绑定就行了，当服务器初始化完毕后我们就可以启动服务器了。

服务器实际上就是在周而复始的为我们提供某种服务，服务器之所以称为服务器，是因为服务器运行起来后就永远不会退出，因此服务器实际执行的是一个死循环代码。由于UDP服务器是不面向连接的，因此只要UDP服务器启动后，就可以直接读取客户端发来的数据。

```C
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

* sockfd：对应操作的文件描述符。表示从该文件描述符索引的文件当中读取数据。
* buf：读取数据的存放位置。
* len：期望读取数据的字节数。
* flags：读取的方式。一般设置为0，表示阻塞读取。
* src_addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
* addrlen：调用时传入期望读取的src_addr结构体的长度，返回时代表实际读取到的src_addr结构体的长度，这是一个输入输出型参数。

读取成功返回实际读取到的字节数，读取失败返回-1，同时错误码会被设置。

## 关于客户端的绑定问题

* 首先，由于是网络通信，通信双方都需要找到对方，因此服务端和客户端都需要有各自的IP地址和端口号，只不过服务端需要进行端口号的绑定，而客户端不需要。

* 因为服务器就是为了给别人提供服务的，因此服务器必须要让别人知道自己的IP地址和端口号，IP地址一般对应的就是域名，而端口号一般没有显示指明过，因此服务端的端口号一定要是一个众所周知的端口号，并且选定后不能轻易改变，否则客户端是无法知道服务端的端口号的，这就是服务端要进行绑定的原因，只有绑定之后这个端口号才真正属于自己，因为一个端口只能被一个进程所绑定，服务器绑定一个端口就是为了独占这个端口。

* 而客户端在通信时虽然也需要端口号，但客户端一般是不进行绑定的，客户端访问服务端的时候，端口号只要是唯一的就行了，不需要和特定客户端进程强相关。

* 如果客户端绑定了某个端口号，那么以后这个端口号就只能给这一个客户端使用，就是这个客户端没有启动，这个端口号也无法分配给别人，并且如果这个端口号被别人使用了，那么这个客户端就无法启动了。所以客户端的端口只要保证唯一性就行了，因此客户端端口可以动态的进行设置，并且客户端的端口号不需要我们来设置，当我们调用类似于sendto这样的接口时，操作系统会自动给当前客户端获取一个唯一的端口号。

* 也就是说，客户端每次启动时使用的端口号可能是变化的，此时只要我们的端口号没有被耗尽，客户端就永远可以启动。

作为一个客户端，它必须知道它要访问的服务端的IP地址和端口号，因此在客户端类当中需要引入服务端的IP地址和端口号，此时我们就可以根据传入的服务端的IP地址和端口号对对应的成员进行初始化。

当客户端初始化完毕后我们就可以将客户端运行起来，由于客户端和服务端在功能上是相互补充的，既然服务器是在读取客户端发来的数据，那么客户端就应该想服务端发送数据。

UDP客户端发送数据的函数叫做`sendto`，该函数的函数原型如下：
```C
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
```
* `sockfd`：对应操作的文件描述符。表示将数据写入该文件描述符索引的文件当中。
* `buf`：待写入数据的存放位置。
* `len`：期望写入数据的字节数。
* `flags`：写入的方式。一般设置为0，表示阻塞写入。
* `dest_addr`：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。 
* `addrlen`：传入   dest_addr结构体的长度。
写入成功返回实际写入的字节数，写入失败返回-1，同时错误码会被设置。

1. 由于UDP不是面向连接的，因此除了传入待发送的数据以外还需要指明对端网络相关的信息，包括IP地址和端口号等。

2. 由于sendto函数提供的参数也是struct sockaddr*类型的，因此我们在传入结构体地址时需要将struct sockaddr_in*类型进行强转。