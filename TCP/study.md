## 服务端监听
* UDP服务器的初始化操作只有两步，第一步就是创建套接字，第二步就是绑定。而TCP服务器是面向连接的，客户端在正式向TCP服务器发送数据之前，需要先与TCP服务器建立连接，然后才能与服务器进行通信。

* 因此TCP服务器需要时刻注意是否有客户端发来连接请求，此时就需要将TCP服务器创建的套接字设置为监听状态。

- listen函数
```C
int listen(int sockfd, int backlog);
```
* `sockfd`：需要设置为监听状态的套接字对应的文件描述符。
* `backlog`：全连接队列的最大长度。如果有多个客户端同时发来连接请求，此时未被服务器处理的连接就会放入连接队列，该参数代表的就是这个全连接队列的最大长度，一般不要设置太大，设置为5或10即可。

## 服务端获取连接

* TCP服务器初始化后就可以开始运行了，但TCP服务器在与客户端进行网络通信之前，服务器需要先获取到客户端的连接请求。

accept函数
```C
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
* `sockfd`：特定的监听套接字，表示从该监听套接字中获取连接。
* `addr`：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
* `addrlen`：调用时传入期望读取的addr结构体的长度，返回时代表实际读取到的addr结构体的长度，这是一个输入输出型参数。

返回值说明：

    获取连接成功返回接收到的套接字的文件描述符，获取连接失败返回-1，同时错误码会被设置。


监听套接字与accept函数返回的套接字的作用：

- 监听套接字：用于获取客户端发来的连接请求。accept函数会不断从监听套接字当中获取新连接。
accept函数返回的套接字：用于为本次accept获取到的连接提供服务。监听套接字的任务只是不断获取新连接，而真正为这些连接提供服务的套接字是accept函数返回的套接字，而不是监听套接字。


## 服务端在获取连接时需要注意：

1. accept函数获取连接时可能会失败，但TCP服务器不会因为获取某个连接失败而退出，因此服务端获取连接失败后应该继续获取连接。

2. 如果要将获取到的连接对应客户端的IP地址和端口号信息进行输出，需要调用inet_ntoa函数将整数IP转换成字符串IP，调用ntohs函数将端口号由网络序列转换成主机序列。

3. inet_ntoa函数在底层实际做了两个工作，一是将网络序列转换成主机序列，二是将主机序列的整数IP转换成字符串风格的点分十进制的IP。


* 由于客户端不需要绑定，也不需要监听，因此当客户端创建完套接字后就可以向服务端发起连接请求。

connect函数
```C
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
* sockfd：特定的套接字，表示通过该套接字发起连接请求。
* addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
* addrlen：传入的addr结构体的长度。

连接或绑定成功返回0，连接失败返回-1，同时错误码会被设置。

需要注意的是，客户端不是不需要进行绑定，而是不需要我们自己进行绑定操作，当客户端向服务端发起连接请求时，系统会给客户端随机指定一个端口号进行绑定。因为通信双方都必须要有IP地址和端口号，否则无法唯一标识通信双方。也就是说，如果connect函数调用成功了，客户端本地会随机给该客户端绑定一个端口号发送给对端服务器。
