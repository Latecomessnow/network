## 服务端监听
* UDP服务器的初始化操作只有两步，第一步就是创建套接字，第二步就是绑定。而TCP服务器是面向连接的，客户端在正式向TCP服务器发送数据之前，需要先与TCP服务器建立连接，然后才能与服务器进行通信。

* 因此TCP服务器需要时刻注意是否有客户端发来连接请求，此时就需要将TCP服务器创建的套接字设置为监听状态。

- listen函数
```C
int listen(int sockfd, int backlog);
```
* `sockfd`：需要设置为监听状态的套接字对应的文件描述符。
* `backlog`：全连接队列的最大长度。如果有多个客户端同时发来连接请求，此时未被服务器处理的连接就会放入连接队列，该参数代表的就是这个全连接队列的最大长度，一般不要设置太大，设置为5或10即可。

## 服务端获取连接

* TCP服务器初始化后就可以开始运行了，但TCP服务器在与客户端进行网络通信之前，服务器需要先获取到客户端的连接请求。

accept函数
```C
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
```
* `sockfd`：特定的监听套接字，表示从该监听套接字中获取连接。
* `addr`：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
* `addrlen`：调用时传入期望读取的addr结构体的长度，返回时代表实际读取到的addr结构体的长度，这是一个输入输出型参数。

返回值说明：

    获取连接成功返回接收到的套接字的文件描述符，获取连接失败返回-1，同时错误码会被设置。


监听套接字与accept函数返回的套接字的作用：

- 监听套接字：用于获取客户端发来的连接请求。accept函数会不断从监听套接字当中获取新连接。
accept函数返回的套接字：用于为本次accept获取到的连接提供服务。监听套接字的任务只是不断获取新连接，而真正为这些连接提供服务的套接字是accept函数返回的套接字，而不是监听套接字。


## 服务端在获取连接时需要注意：

1. accept函数获取连接时可能会失败，但TCP服务器不会因为获取某个连接失败而退出，因此服务端获取连接失败后应该继续获取连接。

2. 如果要将获取到的连接对应客户端的IP地址和端口号信息进行输出，需要调用inet_ntoa函数将整数IP转换成字符串IP，调用ntohs函数将端口号由网络序列转换成主机序列。

3. inet_ntoa函数在底层实际做了两个工作，一是将网络序列转换成主机序列，二是将主机序列的整数IP转换成字符串风格的点分十进制的IP。


* 由于客户端不需要绑定，也不需要监听，因此当客户端创建完套接字后就可以向服务端发起连接请求。

connect函数
```C
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
```
* sockfd：特定的套接字，表示通过该套接字发起连接请求。
* addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
* addrlen：传入的addr结构体的长度。

连接或绑定成功返回0，连接失败返回-1，同时错误码会被设置。

需要注意的是，客户端不是不需要进行绑定，而是不需要我们自己进行绑定操作，当客户端向服务端发起连接请求时，系统会给客户端随机指定一个端口号进行绑定。因为通信双方都必须要有IP地址和端口号，否则无法唯一标识通信双方。也就是说，如果connect函数调用成功了，客户端本地会随机给该客户端绑定一个端口号发送给对端服务器。


////////////////////////////////////////////////////////////////////////////////////

## 多进程版TCP服务器

* 子进程继承父进程的文件描述符表

需要注意的是，文件描述符表是隶属于一个进程的，子进程创建后会继承父进程的文件描述符表。比如父进程打开了一个文件，该文件对应的文件描述符是3，此时父进程创建的子进程的3号文件描述符也会指向这个打开的文件，而如果子进程再创建一个子进程，那么子进程创建的子进程的3号文件描述符也同样会指向这个打开的文件。

但当父进程创建子进程后，父子进程之间会保持独立性，此时父进程文件描述符表的变化不会影响子进程。最典型的代表就是匿名管道，父子进程在使用匿名管道进行通信时，父进程先调用pipe函数得到两个文件描述符，一个是管道读端的文件描述符，一个是管道写端的文件描述符，此时父进程创建出来的子进程就会继承这两个文件描述符，之后父子进程一个关闭管道的读端，另一个关闭管道的写端，这时父子进程文件描述符表的变化是不会相互影响的，此后父子进程就可以通过这个管道进行单向通信了。

对于套接字文件也是一样的，父进程创建的子进程也会继承父进程的套接字文件，此时子进程就能够对特定的套接字文件进行读写操作，进而完成对对应客户端的服务。

### 等待子进程问题

当父进程创建出子进程后，父进程是需要等待子进程退出的，否则子进程会变成僵尸进程，进而造成内存泄漏。因此服务端创建子进程后需要调用wait或waitpid函数对子进程进行等待。

阻塞式等待与非阻塞式等待：

* 如果服务端采用阻塞的方式等待子进程，那么服务端还是需要等待服务完当前客户端，才能继续获取下一个连接请求，此时服务端仍然是以一种串行的方式为客户端提供服务。
* 如果服务端采用非阻塞的方式等待子进程，虽然在子进程为客户端提供服务期间服务端可以继续获取新连接，但此时服务端就需要将所有子进程的PID保存下来，并且需要不断花费时间检测子进程是否退出。

总之，服务端要等待子进程退出，无论采用阻塞式等待还是非阻塞式等待，都不尽人意。此时我们可以考虑让服务端不等待子进程退出。
### 不等待子进程退出的方式
* 捕捉SIGCHLD信号，将其处理动作设置为忽略。
* 让父进程创建子进程，子进程再创建孙子进程，最后让孙子进程为客户端提供服务。

## 1. 捕捉SIGCHLD信号
实际当子进程退出时会给父进程发送SIGCHLD信号，如果父进程将SIGCHLD信号进行捕捉，并将该信号的处理动作设置为忽略，此时父进程就只需专心处理自己的工作，不必关心子进程了。

## 2. 让孙子进程提供服务
我们也可以让服务端创建出来的子进程再次进行fork，让孙子进程为客户端提供服务， 此时我们就不用等待孙子进程退出了。

* 爷爷进程：在服务端调用accept函数获取客户端连接请求的进程。
* 爸爸进程：由爷爷进程调用fork函数创建出来的进程。
* 孙子进程：由爸爸进程调用fork函数创建出来的进程，该进程调用Service函数为客户端提供服务。

我们让爸爸进程创建完孙子进程后立刻退出，此时服务进程（爷爷进程）调用wait/waitpid函数等待爸爸进程就能立刻等待成功，此后服务进程就能继续调用accept函数获取其他客户端的连接请求。

## 关闭对应的文件描述符

* 服务进程（爷爷进程）调用accept函数获取到新连接后，会让孙子进程为该连接提供服务，此时服务进程已经将文件描述符表继承给了爸爸进程，而爸爸进程又会调用fork函数创建出孙子进程，然后再将文件描述符表继承给孙子进程。

* 而父子进程创建后，它们各自的文件描述符表是独立的，不会相互影响。因此服务进程在调用fork函数后，服务进程就不需要再关心刚才从accept函数获取到的文件描述符了，此时服务进程就可以调用close函数将该文件描述符进行关闭。

* 同样的，对于爸爸进程和孙子进程来说，它们是不需要关心从服务进程（爷爷进程）继承下来的监听套接字的，因此爸爸进程可以将监听套接字关掉。


监控进程：
```Makefile
while :; do ps axj | head -1 && ps axj | grep tcp_server | grep -v grep;echo "######################";sleep 1;done
```

监控线程：
```Makefile
while :; do ps -aL|head -1&&ps -aL|grep tcp_server;echo "####################";sleep 1;done
```